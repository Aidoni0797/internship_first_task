5.6 Page Scrolling

Прокрутка содержимого страницы способ1 execute_script()

Полоса прокрутки представляет собой тонкую длинную часть на краю диплея компьютера. Используя  полосу
прокрутки, мы можем просматривать весь контент или всю страницу, прокручивая ее вверх-вниз или
влево-вправо с помощью мыши.

Самый простой способ прокрутки страницы по пикселю - это использование метода .execute_script(),
который выполняет код javascript на странице. К примеру, window.scrollBy(0,5000) прокрутит страницу
вниз на 5000 пикселей.

Можете проверить на этом сайта (https://parsinger.ru/scroll/1/) 

window.scrollBy(X,Y);

- X - смещение в пикселях по горизонтали;
- Y - смещение в пикселях по вертикали.

import time
from selenium import webdriver

with webdriver.Chrome() as browser:
  browser.get('http://parsinger.ru/scroll/1/')
  browser.execute_script("window.scrollBy(0,5000)")
  time.sleep(10)

Такой способ имеет свои преимущества, простота использования - одно из них. Недостаток такого способа в
том, что если сайт отдает данные при кажждом скроллинге, вам придется ждать, пока сервер загрузит данные.
К примеру, на степике комменатрии загружаются по 17 шт, и если под степом 170 комментариев, то вам
придется сделать 10 скроллов, чтобы получить их все. Каждая загрузка 17 комментариев занимает приерно
2-3 секунды, соответственно, вам необходимо устанавливать майминги. Самый простой способ сделать это - 
time.sleep(3).

Напишем простой код, который прокрутит страницу в низ.

import time
from selenium import webdriver

with webdriver.Chrome() as browser:
  browser.get('http://parsinger.ru/scroll/1/')
  for i in range(1):
    browser.execute_script("window.scrollBy(0,5000)")
    time.sleep(2)

Мы сделали 10 итераций и не оказались в самом низу страницы. Потому что мы не знаем, сколько пикселей
имеет в высоту наш сайт. Мы можем использовать большие значения, к прмеру, window.scrollBy(0,5000000),
такие большие цифры за один скроллинг способы прокрутить всю страницу. И это то, что вы будете делать,
когда у вас обычный сайт без прогрузки данных.

Представим, что у вас сайт, который имеет разные высоты страницы. Мы можем получить значение высоты
непосредственно той части сайта, которая попадает в область вашей видимости, или значение высоты сайта
полностью.

return document.body.scrollHeight вернёт значение высоты основного элемента на странице - body

import time
from selenium import webdriver

with webdriver.Chrome() as browser:
  browser.get('http://parsinger.ru/scroll/1/')
  height = browser.execute_script("return document.body.scrollHeight")
  time.sleep(2)
  print(height)

81000 пикселей имеет в высоту наш сайт. Для того, чтобы вычислить высоту видимой области сайта,
используется скрипт

Используется код window.innerHeight для получения высоты, или window.innerHeight - для получения
ширины видимой области.

from selenium import webdriver

with webdriver.Chrome() as browser:
  browser.get('http://parsinger.ru/scroll/1/')
  height = browser.execute_script("return window.innerHeight")
  print(height)

>>>887

887 пикселей имеет видимая часть нашего сайта. Иногда необходимо, чтобы требуемый элемент находился в
видимой области, т.к. методы .click(), .send_keys() и др. не могут быть совершены если элемент не 
находится в видимой области экрана.

Если вам необходимо совершить скроллинг в самый низ к последнему пикселю одним из самых простых способов,
то используйте скрипт "window.scrollTo(0, document.body.scrollHeight)"

import time
from selenium import webdriver

with serbdriver.Chrome() as browser:
  browser.get('http://parsinger.ru/scroll/1/')
  browser.execute_script("window.scrollTo(0, document.body.scrollHeight);")
  time.sleep(2)

При написании парсеров, часто необходимо сперва совершить необходимое количество скроллинга, чтобы
загрузилась вся необходимая вам информация. После того как вся нужная инфа появилась на странице, мы
собираем всё при помощи .find_elements(), но об этом мы будем говорить далее.

.execute_script()

Синтаксис webdriver.execute_script(script, *args).

В .execute_script() можно использовать следующие полезные параметры.
Посмотреть все события можно тут (https://developer.mozilla.org/ru/docs/Web/API/Document) и тут 
(https://developer.mozilla.org/ru/docs/Web/API/Window), ниже приведены те, которые чаще всего 
используются при написании парсеров.

- .execute_script("return arguments[0].scrollIntoView(true);", element) - прокручивает родительский
контейнер элемента таким образом, чтобы element, для которого вызывается scrollIntoView,
был виден пользователю;

- .execute_script("window.open('http://parsinger.ru', 'tab2');") - создаст новую вкладку с синем
'tab2';

- .execute_script("return document.body.scrollHeight") - вернет значение высоты элемента <body>;

- .execute_script("return window.innerHeight") - вернет значение высоты окна браузера;

- .execute_script("return window.innerWidth") - вернет значение ширину окна браузера;

- .execute_script("window.scrollBy(X,Y)") - прокручивает документ на заданное число пикселей;

- X - смещение пикселей по горизонтали;
- Y - смещение в пикселях по вертикали;

- .execute_script("alert('Ура Selenium')") - вызывает модальное окно Alert;

- .execute_script("return document.title;") - вернет title открытого документа;

- .execute_script("return document.dicumentURI;") - возвращает URL документа;

- .execute_script("return document.readyState;") - возвращает состояние загрузки страницы, вернет
complete если страница загрузилась;

- .execute_script("return document.anchors;") - возвращает список всех якорей (https://htmlbook.ru/samhtml/yakorya);

- [x.tag_name for x inn browser.execute_script("return document.anchors;")] - такой код даст возможность 
получить список всех тегов с якорями. Очень полезная инструкция, используется если при скроллинге мы не 
можем найти элемент, за который можно "зацепится";

- .execute_script("return document.cookie;") - возвращает список файлов cookie, разделенных точкой с
запятой;

- .execute_script("return document.domain;") - возвращает домен текущего документа;

- .execute_script("return document.forms;") - вернет список форм;

- window.scrollTo(x-coord, y-coord) - прокрутка документа до указанных координат;

- x-coord пиксель по горизонтальной оси документа, будет отображен вверху слева;
- y-coord пиксель по вертикальной оси документа, будет отображен вверху слева.

- .execute_script("return document.getElementByClassName('container');") - возвращает список всех лементов
с заданным классом class='container';

- .execute_script("return document.getElementByTagName('container');") - возвращает список всех элементов
с заданным именем name="container".


Прокрутка содержимого страницы - способ 2 Keys()

Второй способ прокрутки содержимого с использованием класса Keys() из модуля Selenium.

Импортируем: from selenium.webdriver import Keys или from selenium.webdriver.common.keys import Keys

Откроем наш сайт (https://parsinger.ru/scroll/1/), на нем есть 100 тегов <input>, с которыми мы и
будем взаимодействовать. Взаимодействовать мы можем только с интерактивными элементами -
это кнопки, ссылки, различные imnput-ы, и другие, а не интерактивные - это абзацы с текстом,
различные элементы списка li и табличные элементы tr, td и другие. Для того, чтобы лучше понять
интерактивный элемент перед вами или нет, нажмите несколько раз клавишу TAB на клавиатуре, если
элемент выделяется, то он интерактивный.

import time
from selenium.webdriver import Keys
from selenium import webdriver
from selenium.webdriver.common.by import By

with webdriver.Chrome() as browser:
  browser.get('http://parsinger.ru/scroll/1/')
  tag_p = browser.find_element(By.TAG_NAME, 'input').send_keys(Keys.DOWN)
  time.sleep(10)

Выполнив этот код у себя (ну у iDONi как всегда не спервого раза, ладно ChatGPT ты крутой) в
терминале, вы увидите, что на открывшимся сайте получил выделение первый тег <input>,
потому что метод .find_element() возвращает первый найденный элемент.

Для того, чтобы взаимодействовать подобным образом с остальными элементами <input>, нам уже
потребуется цикл while, если мы не знаем точного количества элементов, или цикл for, если точное
количество элементов нам известно.

import time
from selenium.webdriver import Keys
from selenium import webdriver
from selenium.webdriver.common.by import By

with webdriver.Chrome() as browser:
  browser.get('http://parsinger.ru/scroll/1/')
  tags_input = browser.find_elements(By.TAG_NAME, 'input')

  for input in tags_input:
    input.send_keys(Keys.DOWN)
    time.sleep(1)
