8.6 Core Methods and Functions of Asyncio

Функция run()

Функция asyncio.run(main()) - создает новый цикл событий и запускает в нем переданную сопрограмму,
после выполнения всех сопрограмм закрывает цикл событий. Функция run()  не может быть вызвана дважды
в одном потоке. Эта функция служит основной точкой входа и выхода из цикла событий, при написании
парсеров мы будем запускать ее только один раз.

Код ниже является элементарным использованием асинхронного кода с использованием асинхронной
функции asyncio.sleep(). В коде ниже функция run() создает цикл событий в момент своего вызова, в нее
мы передаем сопрограмму one(), которая первым делом напечатает hello, после чего асинхронно уснет
на одну секунду, имитируя выполнение чего-то очень важного в этом месте. Засыпая, она отдает управление
другому awaitable-объекту, а именно сопрограмме two(), которая напечатает нам слово world, после
этого снова вернет управление в сопрограмму one(), в которой остался последний шаг - напечатать слово 
end! После выполнения всех шагов run() закроет цикл событий до следующего запуска кода.

import asyncio

async def two():
  print('world')

async def one():
  print('hello')
  await asyncio.sleep(1)
  await two()
  print('end!')

asyncio.run(one())

#Результат
  hello  
  world
  end!

На таком простом примере можно понять, как происходит переключение между awaitable-объектами. Если вы
не поняли, как это работает, советую запустить код у себя и поэкспериментировать с ним. Я думаю,
у вас все получится!

И кстати, когда вы будете изучать асинхронное программирование самостоятельно по другим материалам в
интернете, помните, что функция run() относительно новая, поэтому вы можете встретить стариый синтаксис
запуска фикла событий.

import asyncio

async def two():
  print('world')

async def one():
  print('hello')
  await asyncio.sleep(1)
  await two()
  print('end!')

loop = asyncio.get_event_loop()
loop.run_until_complete(one())

#Результат
hello
world
end!

Результат будет точно такой же, только вы получите предупреждение об устаревании, возможно, однажды
старый вариант перестанет работать СОВСЕМ.

DeclarationWarning: There is no current event loop loop = asyncio.get_event_loop()

#iDONi этого событие в твоей жизне получилось

Функция sleep() #iDONi ты просто обязана это понимать потому что ты любишь sleep жизненно

await asyncio.sleep(3) - в модуле asyncio есть своя асинхронная слип, она выполняет то же самое, что и ее
синхронная "сестра", за одним исключением: асинхронная версия sleep() умеет передавать управление,
когда она усыпляет сопрограмму.

Код ниже напечатает Hello world через пять секунд сна. Перед сопрограммой sleep() всегда ставится
оператор await, т.к. все сопрограммы являются awaitable-объектами, которые передают управление, когда
встречают оператор await.

#Псевдокод который демонстрирует использование асинхронной сопрограммы sleep()

import asyncio

async def sleep():
  await asyncio.sleep(5)
  print('Hello world')

asyncio.run(sleep())
