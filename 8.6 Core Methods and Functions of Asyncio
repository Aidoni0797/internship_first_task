8.6 Core Methods and Functions of Asyncio

Функция run()

Функция asyncio.run(main()) - создает новый цикл событий и запускает в нем переданную сопрограмму,
после выполнения всех сопрограмм закрывает цикл событий. Функция run()  не может быть вызвана дважды
в одном потоке. Эта функция служит основной точкой входа и выхода из цикла событий, при написании
парсеров мы будем запускать ее только один раз.

Код ниже является элементарным использованием асинхронного кода с использованием асинхронной
функции asyncio.sleep(). В коде ниже функция run() создает цикл событий в момент своего вызова, в нее
мы передаем сопрограмму one(), которая первым делом напечатает hello, после чего асинхронно уснет
на одну секунду, имитируя выполнение чего-то очень важного в этом месте. Засыпая, она отдает управление
другому awaitable-объекту, а именно сопрограмме two(), которая напечатает нам слово world, после
этого снова вернет управление в сопрограмму one(), в которой остался последний шаг - напечатать слово 
end! После выполнения всех шагов run() закроет цикл событий до следующего запуска кода.

import asyncio

async def two():
  print('world')

async def one():
  print('hello')
  await asyncio.sleep(1)
  await two()
  print('end!')

asyncio.run(one())

#Результат
  hello  
  world
  end!

На таком простом примере можно понять, как происходит переключение между awaitable-объектами. Если вы
не поняли, как это работает, советую запустить код у себя и поэкспериментировать с ним. Я думаю,
у вас все получится!

И кстати, когда вы будете изучать асинхронное программирование самостоятельно по другим материалам в
интернете, помните, что функция run() относительно новая, поэтому вы можете встретить стариый синтаксис
запуска фикла событий.

import asyncio

async def two():
  print('world')

async def one():
  print('hello')
  await asyncio.sleep(1)
  await two()
  print('end!')

loop = asyncio.get_event_loop()
loop.run_until_complete(one())

#Результат
hello
world
end!

Результат будет точно такой же, только вы получите предупреждение об устаревании, возможно, однажды
старый вариант перестанет работать СОВСЕМ.

DeclarationWarning: There is no current event loop loop = asyncio.get_event_loop()

#iDONi этого событие в твоей жизне получилось

Функция sleep() #iDONi ты просто обязана это понимать потому что ты любишь sleep жизненно

await asyncio.sleep(3) - в модуле asyncio есть своя асинхронная слип, она выполняет то же самое, что и ее
синхронная "сестра", за одним исключением: асинхронная версия sleep() умеет передавать управление,
когда она усыпляет сопрограмму.

Код ниже напечатает Hello world через пять секунд сна. Перед сопрограммой sleep() всегда ставится
оператор await, т.к. все сопрограммы являются awaitable-объектами, которые передают управление, когда
встречают оператор await.

#Псевдокод который демонстрирует использование асинхронной сопрограммы sleep()

import asyncio

async def sleep():
  await asyncio.sleep(5)
  print('Hello world')

asyncio.run(sleep())

Функция create_task()

Функция asyncio.create_task(coro) оборачивает сопрограмму в task и планирует ее выполнение. Эта 
функция возвращает объект <class '_asyncio.Task'>. Вы уже видели примеры использования тасков в коде.
Вы можете запланировать выполнение любого количества тасков, именно этот механизм помогает нам создавать
большое количество задач для наших сопрограмм.

Код ниже показывает элементарный пример создания двух тасков. Обратите внимание, что функция
принимает в качестве аргументов сопрограммы One() and two(). Этот пример не совсем отображает принцип
асинхронного выполнения, т.к. в нем нет блокирующих команд, все происходит по порядку, сперва
печатает 1 затем 2.

import asyncion

async def two(x):
  return print(x)

async def one(x):
  return print(x)

async def main():
  task1 = asyncio.create_task(one(1))
  task2 = asyncio.create_task(two(2))
  await task1
  await task2

asyncio.run(main())

#Результат
1
2

Теперь добавим в эти сопрограммы элемент случайности, а именно встроенную сопрограмму
asyncio.sleep(), она помогает сопрограмме рандомно заснуть на период от одной секунды до пяти секунд,
тем самым имитируя работу. При запуске этого кода несколько раз, результат будет зависеть от того,
какая сопрограмма спит дольше. Пока одна сопрограмма спит, управление передается другой, об этом 
говорит оператор await.

import asyncio
import random

async def two(x):
  await asyncio.sleep(random.randint(1,6))
  return print(x)

async def one(x):
  await asyncio.sleep(random.randint(1,6))
  return print(x)

async def main():
  task1 = asyncio.create_task(one(1))
  task2 = asyncio.create_task(two(2))
  await task1
  await task2

asyncio.run(main())

Добавим немного итераций в код. Каждая сопрограмма будет выполнена по пять раз, засыпая на рандомное
время. Здесь уже лучше видно, как работает асинхронность, котому что у нас уже есть результат,
отображающий ход выполнения асинхронного кода. При запуске этого кода результат будет всегда разный.

import asyncio
import random

async def two(x):
  await asyncio.sleep(random.randint(1,3))
  return print(x)

async def one(x):
  await asyncio.sleep(random.randint(1,3))
  return print(x)

async def main():
  for x in range(5):
    task1 = asyncio.create_task(one(1))
    task2 = asyncio.create_task(two(2))
    await task1
    await task2

asyncio.run(main())

#Результат
1
2
2
1
1
2
2
1
1
2


Такой подход не очень удобен, потому что вы не можете создавать отдельный таск на каждый запрос - это
заняло бы кучу времени и убило бы все удовольствие от программирования. Для этого существуют две
основные функции - asyncio.gather() и asyncio.wait(). Забегая вперед, отмечу, что они отлично работают 
с объектами ожидания, которыми и являются таски.

Функция gather()

Функция asyncio.gather(*coros) одновременно запускает все awaitable-объекты, переданные как
последовательность, и передает для запуска в цикле событий. Функция asyncio.gather() является
awaitable-объектом и запускается оператором await. Если вы передаете функции gather() сопрограмму,
то она будет автоматически назначена как задача <class '_asyncio.Task'>

asyncio.gather(*aws) возвращает список готовых результатов, которые были выполнены объектами
ожидания. Это значит, что вы сперва настраиваете и создаете таски, после чего передаете распокованный
список в функцию gather(), и когда результат с тасков получен, gather() вернет список, состоящий из
результатов выполнения каждой сопрограммы.

Код ниже демонстрирует, как передавать сразу несколько сопрограмм в функцию gather(). В этом коде на
каждой итерации происходит одновременный запуск двух сопрограмм.

import asyncio
import random

async def two(x):
  await asyncio.sleep(random.randint(1,3))
  return print(x)

async def one(x):
  await asyncio.sleep(random.randint(1,3))
  return print(x)

async def main():
  for x in range(5):
    await asyncio.gather(one(1), two(2))

asyncio.run(main())


Для создания асинхронных парверов вы, скорее всего, будете использовать подход, который представлен
ниже. Он позволяет генерировать запуск сопрограмм в любом количестве, которое будет зависеть только от
того, сколько страниц вам нужно обработать. В этом коде мы создали список let, которые генерирует 10 чисел,
которые мы передаем в сопрограмму one(x), предварительно создав задачу для выполнения функцией
asyncio.create_task(). Как вы помните, результатом выполнения этой функции является объект <class 
'_asyncio.Task'>. Каждая созданная задача отправляется в созданный заранее список lst_tasks который
содержит десять задач, далее этот список в распокованном виде мы передаем в функцию gather() для
одновременного запуска всех задач в асинхронном стиле.

Сопрограмма one() имитирует свою деятельность простым засыпанием, каждое ее засыпание можно сравнить
с отправкой запроса к серверу, ведь по сути, циклу событий нет разницы, по какой причине сопрограмма
передает управление следующему awaitable-объекту.

import asyncio
import random

async def one(x):
  await asyncio.sleep(random.randint(1,3))
  return print(x)

async def main():
  lst = [x for x in range(10)]
  lst_tasks = []
  for x in lst:
    task = asyncio.create_task(one(x))
    lst_tasks.append(task)
  await asyncio.gather(*lst_tasks)

asyncio.run(main())

#Результат
2
6
9
0
4
1
8
5
7
3

Функция asyncio.gather() в некоторых случаях полезна тем, что она помогает группировать сопрограммы и
запускать их одновременно. Это может пригодится для одновременного парсинга нескольких разных сайтов.
Есть точка входа - сопрограмма main(), которая выполняет сбор всех сопрограмм и их запуск, и есть 
сопрограммы one(), two(), three(), которые могут собирать данные с выбранных сайтов. Также стоит 
помнить, что сопрограмму asyncio.gather() необходимо передавать распокаванное множество,
распаковка происходит с помощью символа *.

*Подмножеством подразумевается не конкретный тип данных set(), а понятие множества в целом, такие
множества как list(), tuple(), set() и др.

import asyncio
import random

async def one(x):
  await asyncio.sleep(random.randint(1,3))
  return print(x)

async def two(x):
  await asyncio.sleep(random.randint(1,3))
  return print(x)

async def three(x):
  await asyncio.sleep(random.randint(1,3))
  return print(x)

async def main():
  group1 = asyncio.gather(*[one(i) for i in range(1,10)])
  group2 = asyncio.gather(*[two(i) for i in range(1,10)])
  group3 = asyncio.gather(*[three(i) for i in range(1,10)])

  await asyncio.gather(group1, group2, group3)

asyncio.run(main())

Функция wait()

Функция asyncio.wait(list_task) имеет схожий функционал с asyncio.gather(), они обу запускают
одновременно переданные awaitable-объекты. Для написания парсеров нет большой разницы, какую из этих
функций использовать, т.к. мы будем выполнять только запросы к серверу и сохранение данных в файл.

Так в чём разница,

asyncio.gather() - фикусируется на сборе результатов, она ждет кучу awaitable-объектов и возвращает
полученный от них результат. Также каждая задача или группа задач может быть отменена методом
.cancel(), для написания парсеров мы этим функционалом пользоваться не будем. Является высокоуровневым
решением.

asyncio.wait() - точно так же ждет awaitable-объекты и точно так же все переданные задачи будут
оборачиваться в <class '_asyncio.Task'>. Ключевым отличием является то, что в asyncio.wait(timeout=2)
может быть использован timeout, когда время ожидания сопрограммы истекает, вызывается исключение
TimeoutError.

Мы можем взять код с прошлого степа и заменить функцию gather() функцией wait(), программа
продолжит работать точно так же.

import asyncio
import random

async def one(x):
  await asyncio.sleep(random.randint(1,3))
  return print(x)

async def main():
  lst = [x for x in range(10)]
  lst_tasks = []
  for x in lst:
    task = asyncio.create_task(one(x))
