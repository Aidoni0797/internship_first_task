5.4 Finding Elements with Selenium

Поиск элементов Selenium - https://www.selenium.dev/documentation/

Вспоминаем урок Поиск элементов на странице (iDONi ничего не помнить, вообще не понимаю
как можно всю информацию можно запоминать, это нереально кажется). Перечитайте его чтобы
вспомнить содержимое, и пусть он будет открыт во второй вкладке чтобы подглядывать.

Существует два набора методов Selenium для поиска элементов на странице. Я продемонстрирую оба,
а вы выберите то, что будет для вас удобнее и лучше подойдет к конкретной ситуации (лично я предпочитаю
второй набор).

- .find_element_by_id("tag") - поиск по уникальному атрибуту id элемента. Лучше использовать именно
поиск по id, т.к. мы знаем что на странице может быть только 1 элемент с уникальным id, такой поиск
является самым стабильным;
- .find_element_by_css_selector("tag") - используйте этот способ, когда хотите получить элемент с
использованием синтаксиса CSS-селекторов;
- .find_element_by_xpath("path") - поиск с помощью языка запросов XPath, позволяет выполнять очень гибкий
поиск элементов. Одно из веских оснований использовать XPath - ситуации, когда на тсранице отсутствуют
пригодные в качестве указателей атрибуты, такие как id или name;
- .find_element_by_name("tag") - используйте этот способ, когда известен атрибут name элемента. Результатом
будет первый элемент с искомым значением атрибута name;
- .find_element_by_tag_name("tag") - поиск элеента по названию тега элемента;
- .find_element_by_class_name("tag") - поиск по значению атрибута class;
- .find_element_by_link_text("tag") - используйте этот способ, когда известен текст внутри тега;
- .find_element_partial_link_text("tag") -  поиск ссылки на странице, если текст селектора совпадает с любой 
частью текста ссылки.

Стоит отметить, что этот набор методов немного устарел. Хотя до сих пор все работает, но PyCharm намекает =)
******************
Второй набор методов поиска называется локаторами и полностью эквивалентен первому набору методов по функционалу.

Перед использованием локатора нам необходимо его импортировать:

from selenium.webdriver.common.by import By

Локаторы играют очень важную роль при работе с Selenium. Он обеспечивают путь к веб-элементам, которые
необходимы для автоматизации определенных действий, таких как клик, ввод, установка флага и др.
- .By.ID - поиск по уникальному атрибуту id элемента;
- .By.CSS_SELECTOR - поиск элементов с помощью правил на основе CSS;
- .By.XPATH - поиск элементов с помощью языка запросов XPath;
- .By.NAME - поиск по атрибуту name элемента;
- .By.TAG_NAME - поиск по названию тега;
- .By.CLASS_NAME - поиск по атрибуту class элемента;
- .By.LINK_TEXT - поиск ссылки с указанным текстом. Текст ссылки должен быть точным совпадением;
- .By.PARTIAL_LINK_TEXT -поиск ссылки по частичному совпадению текста.

Локаторы мы используем с помощью двух универсальных методов - find_element(). который возвращает ровно
один элемент, найденный первым, и find_elements() который возвращает список найденных элементов.

Сравним два способа. Найдем на странице, кнопку "Купить" с id = "sale_button" и совершим по ней клик.

Вариант 1. .find_element_by_id("sale_button")

from selenium import webdriver

browser =  webdriver.Chrome()
browser.get('http://parsinger.ru/html/watch/1/1_1.html')
button = browser.find_element_by_id("sale_button").click()

- этот код не рабоет (ошибка связано с тем что не поддерживает Selenium устаревшую версию интересно)

ниже предоставляю переделанный код с помощью лучшего друга iDONi ChatGPT(такой умный и отвечат своевременно)
from selenium import webdriver
from selenium.webdriver.common.by import By  # импортируем By

browser = webdriver.Chrome()
browser.get('http://parsinger.ru/html/watch/1/1_1.html')

# Используем современный способ поиска по ID
button = browser.find_element(By.ID, "sale_button").click()

-----------------------------------
Вариант 2. .find_element(By.ID, "sale_button")

from selenium import webdriver
from selenium.webdriver.common.by import By

browser = webdriver.Chrome()
browser.get("http://parsinger.ru/html/watch/1/1_1.html")
button = browser.find_element(By.ID, "sale_button").click()

Думаю, разница понятна. Выбирайте, какой из методов поиска гравится лично вам, и поехали дальше.
**************************************

Работаем с браузером

Когда наш парсер отработает, мы бы хотели, чтобы он закрылся сам и те самым корректно завершил свою
работу. Но этого может не произойти по множеству причин. Поэтому мы должны указать браузеру на то, что
он должен закрыть окно после завершения работы, командой browser.quit(). Важно закрыть окно, потому
что при создании webdriver.Chrome() создается процесс в ОС, который продолжит висеть. Команда .quit()
проще, чем закрывать окно браузера вручную, к тому же, вы не будете засорять оперативную память.

Расстами таймауты, чтобы видеть вручную процесс выполнения кода и чтобы браузер не закрывался за мгновение.

import time
from selenium import webdriver
from selenium.webdriver.common.by import By

browser = webdriver.Chrome()
browser.get('http://parsinger.ru/html/watch/1/1_1.html')
button = browser.find_element(By.ID, "sale_button")
time.sleep(2)
button.click()
time.sleep(2)
browser.quit()

Если ошибка
