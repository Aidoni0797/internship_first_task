2.4 Finding Elements on the Page

Поиск элементов на странице

Все примеры выполнены в браузере Chrome

Элементы можно находить при помощи тегов, селекторов css, атрибутов и их значений.

Например:

-id="name_id" - по идентификатору;
-class="name_class" - по имени классов;
-div - по имени тега;
-href="link" - по атрибуту;
-name="item" - по значению атрибута.

Откройте страницу https://parsinger.ru/html/hdd/4/4_17.html в своем браузере, вызовите инструменты разработчика, нажав F12 или ctrl+u, и откройте панель поиска по дереву
HTML командой ctrl+f. Для закрепления знаний мы будем тренироваться искать элементы в браузере, а затем в разделе, посвященном selenium, мы перейдем к написанию парсеров,
используя знания из этого модуля.

Поиск по #id
#-базовый селектор, который помогает выбирать элемент по значению атрибута id. Работать с этим атрибутом очень удобно: каждое значение id является уникальным объектом на
странице, т.е. вы можете быть уверены, что в HTML-документе существует только один объект с таким id.

Для поиска по id используется синтаксис #значение_атрибута, в нашем случае это #brand. Потренируйтесь писать поиск по id самостоятельно на тругих тегах, также можно
использовать аналогичный синтаксис с квадратными скобками: [id='brand']. Результат будет такой же, как при использовании #brand, только потребует написания большего количества
символов. Какой способ выбрать - решать вам, это дело вкуса.

Поиск по .class
.-базовый селектор, который помогает выбирать элемент по имени класса. Синтаксис очень простой. .имя_класса или .description. Обратите внимание что с помощью поиска мы найдем 
все элементы с таким значением класса, их моожет быть несколько.

Поиск по имени тега
Самый простой способ найти любой тег - просто написать его в строке поиска. Например, headers или div. Такой способ мы можем использовать, если нам нужно собрать все элементы на
странице разом, к примеру все абзацы. 
Важное примечание: Если искать тег, который состоит из одного символа, например, тег или тег p, вы найдете не только теги, но и все буквы, которые есть на странице <meta name="viewport">
Чтобы найти только теги, нужно использовать поиск с угловыми скобками <a> или <p>

Ссылка для поиска - https://parsinger.ru//html/index4_page_1.html

Поиск по значению атрибута name="item"
Ссылка для поиска - https://parsinger.ru//html/index4_page_1.html

В этом степе уже упоминалось о квадратных скобках, с помощью которых можно искать class and id. На самом деле, можно искать таким образом любые теги с любыми атрибутами на странице.


Поиск по составным селекторам

Мы почти всегда можем обратиться к необходимому элементу напрямую и получить его данные. Но представьте ситуацию, когда есть
два одинаковых элемента с совершенно одинаковым классом, но с разными родителями. Как получить какой-то определенный элемент?

В этом примере оба тега <p> имеют одинаковый класс "text". Для того, чтобы получить тег, родительский элемент которого
имеет класс "author", нам и потребуется составной селектор.

' ' (пробел) выбирает элементы, которые находятся внутри указанного элемента (вне зависимости от уровня вложенности).

.author .text - это означает, что мы ищем тег с классом "text", родителем которого является тег с классом "author". 
Элемент .text может находиться на любом уровне вложенности от элемента .author и между ними может быть сколько угодно других тегов.

Или второй пример, где мы хотим извлечь конкретный элемент при помощи составного селектора:
.container .price_box p сайт - https://parsinger.ru/html/index4_page_1.html

Как видите, мы получаем все элементы, которые соответствуют притериями поиска. Глубина вложенности селектора может быть любой.

Потомки или дочерние элементы

'>', в отличие от пробела, выбирает только те элементы, которые являются дочерними непосредственно по отношению к указанному элементу.

.img_box>.name_item - такой способ помогает найти дочерний элемент от его родителя. Элемент с классом .name_item 
дочерний элементу .img_box(англ child), а .img_box для  .name_item является родительским элементом (англ. parent)

Можете сами в этом убедится, откройте сайт - https://parsinger.ru/html/index4_page_1.html и поэкспериментируйте.

Поиск по порядковому номеру дочернего элемента

#description >li:nth-child(3) (https://parsinger.ru/html/hdd/4/4_1.html) - такой способ весьма полезен. :nth-child() может
находить элемент, основываясь на его позиции в списке эелментов. В примере ниже мы нашли элемент под номером 3.
Возможно вы успели привыкнуть, что  в программировании счет начинается с 0, но в поиске по HTVL считают с 1 =) Это просто нужно
запомнить.

Использование двух классов и более
В примере ниже родительские теги имеют сразу 2 класса, их может быть и больше. Чтобы найти элементы у которых есть нужные
нам классы, мы можем использовать:
.main.author - такой составной селектор используется для поиска элемента с двойным классом.
Если классов будет больше, чем мы указали в составном селекторе, то элемент будет найден.

Искомый элемент имеет 5 классов row user user-top nav-bottom margin-bottom, мы находим элемент всего по двум классам.
Важно помнить об этой особенности и указывать более конкретный составной селектор, чтобы в наш поиск не попадали лишние
элементы.

Поиск элементов при помощи XPath

Когда мы не можем найти уникальный селектор для необходимого нам элемента, на помощь приходит поиск по XPath, поиск
атрибута по его пути.

XPath - очень мощный и гибкий инструент, в то же время и очень опасный.

1. Во-первых XPath помогает писать сложные запросы поиска элементов.
2. Во-вторых, если разработчик сайта вдруг решил изменить порядок элементов на странице, то весь код парсер может сломаться,
а искомый элемент не будет найден.

XPath - использует и древовидную структуру документа.

Проверсть XPath - запросы можно так же, как и простые css селекторы - в консоли разработчика.

1. XPath всегда начинается с символа / или //
Символ / аналогичен символу > в CSS-селекторе, символ // - пробелу.

-element1/element2 - выбирает элементы element2, являющиеся прямыми потомками element1;
-element1//element2 - выбирает  элементы element2, являющиеся потомками element1 любой степени сложности.

Разница состоит в том, что в XPath, когда мы начинаем запрос с символа /, мы должны указать элемент являющийся корнем нашего 
документа. Корнем всегда будет элемент с тегом  <html>.
Пример: /html/body/header

Мы можем начинать запрос и  с символа //. Это будет означать, что мы хотим найти всех потомков корневого элемента без
указания корневого элемента. В этом случае для поиска того же хедера, мы можем выполнить запрос //header, так как других
заголовков у нас нет.

2. Символ [ ] - Это команда фильтрации
Если по запросу найдено несколько элементов, то будет произведена фильтрация по правилу, указанному в скобках.

Правил фильтрации очень много:

- по любому атрибуту, будь то id, class, title (или любой другой). Например, мы хотим найти ссылку с заданным id, для этого можно
выполнить запрос на сайте - https://parsinger.ru/html/watch/1/1_1.html //a[@id='a_back'].

- по порядковому номеру. Допустим, мы хотим выбрать пятый по порядку элемент li. Для этого найдем элемент с классом ul и возьмем
его пятого потомка: //ul/li[5].

- по полному совпадению текста. Да, XPath - это единственный способ найти элемент на сайте https://parsinger.ru/html/watch/1/1_1.html
по внутреннему тексту. Если мы хотим найти кнопку "Купить", можно воспользоваться XPath-селектором
//button[text()="Купить"]. Такой селектор вернет элемент, только если текст полностью совподает. Здесь важно сказать, что
не вседа поиск потексту - это хорошая практика, особенно в случае, если сайт мультиязычный.

- по частичному совпадению текста или атрибута. Для этого нужна функция contains.
Запрос //p[contains(text(),"Артикул")] <p class="article">Артикул: BD235265</p> вернет нам все абзацы текста, которые содержат слово Артикул. Точно так же можно искать
по частичному совпадению других атрибутов, это удобно, если у элемента несколько классов. Посмотрите код сайта - https://parsinger.ru/html/watch/1/1_1.html и найдите тег 
ul, а в нем тег li со значением атрибута material_frame and material_bracer, их можно найти селектором //li[contains(@id, "material")]

3. Символ * - Команда выбора всех элементов

- Например, мы хотим найти текст на сайте - https://parsinger.ru/html/index1_page_1.html в заголовке с ценой //div/*[@class="price"]. Это может быть удобно, когда мы
не знаем точно тег элемента, который ищем. Будет найдено 8 элементов соответствующих нашему поиску.

4. Поиск по класссу в XPath зависит от регистра

Так же, как и в случае поиска по CSS-селекторам, будьте внимательными к регистру при поиске по классам:
//div/*[@class="Price"] не найдет элемент на нашей странице.

Что важно знать про XPath, чтобы пользоваться им, безболезненно:

- Не используйте селекторы вида //div[1]/div[2]/div[3] без крайней нужды: по такому селектору невозможно с первого раза понять, что за элемент вы ищете. А когда структура
страницы хоть немного измениться, ваш парсер с большой вероятностью перестанет работать.
- Если есть возможность использовать CSS-селекторы: class, id or name, лучше использовать из вместо поиска по XPath.
- Можно искать по полному или частичному совпадению текста или любого атрибута.
- Можно удобно перемещаться по структуре документа (переходить к потомкам и к родителям);
- Подойдет, когда у сайта все плохо с атрибутами.
* Не стоит использовать разные расширения для браузеров по поиску XPath: они подбирают нечитабельные и переусложненные селекторы. Лучше потратить немного времени и разобраться 
в синтаксисе самостоятельно, тем более, что он не очень сложный.
