5.8 Explicit and Implicit Waits

Явное и неявное ожидание, Selenium Waits (Implicit Waits)

Ни один современный сайт не обходится без JavaScript. Когда вы серфите по интернету, вы часто встречаете
плавно появляющиеся элементы на странице, элементы, которые появляются при скроллинге или при полной
загрузке страницы, вариаций использования JS очень много. К этому уроку у вас уже есть определенный
опыт написания скриптов на Selenium. Я уверен, вы сталкивались с тем, что элемент который вы ищете, еще не 
загрузился или еще не доступен для взаимоодействия с ним.

Перечисленные ситуации будут всегда возникать при написании скриптов, так устроены современные сайты,
без этого никуда. Ранее в курсе мы обходились простыми time.sleep(), это хорошее начало для того, чтобы
понимать как работать с ожиданиями. Представьте ситуацию, что ваш скрипт работает с множеством
элементов, на разных страницах сайта или даже на разных сайтах, и вдруг нужный элемент не загрухился
вовремя и скрипт упал. Уверен, вы сразу напишите в этом месте time.sleep() или даже несколько, чтобы
обезопасить работу. И вот ваш скрипт весь обвешан "слипами" и большую часть времени ваш код спит.

Для таких ситуаций существуют неявные ожидания Implicit Waits. Неявное ожидание называется так, 
потому что его не нужно указывать отдельно как time.sleep().

Откройте сайт, дождитесь активации кнопки и совершите клик по ней. Вы получите сообщение о успешном
клике. Написать код с помощью time.sleep() для такой кнопки очень сложно, потому что на становится
активной спустя от 1 до 3 секунд после загрузки страницы, а потом снова выключается. Ради интереса
можете попробовать написать стабильный код, используя time.sleep(). А если таких кнопок будет не одна,
а десять, и все с разными таймингом?

from selenium import webdriver
fro, selenium.webdriver.commpn.by import By

with webdriver.Chrome() as browser:
  browser.get('http://parsinger.ru/expectations/1/index.html')
  browser.find_element(By.ID, 'btn').click()

Давайте немного модифицируем код выше, чтобы он работал без ошибок. Применим неявные ожидания. О том,
как они работают, мы поговорим в следующих степах и порешаем задачки по ним.

Запустите эти два примера у себя в IDE, чтобы сравнить результат работы.

from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.ui import WebDriverWait

with webdriver.Chrome() as browser:
  browser.get('http://parsinger.ru/expectations/1/index.html')
  element = WebDriverWait(browser, 10).until(EC.element_to_be_clickabkw((By.ID, "btn"))).click()
  print(browser.find_element(By.ID, 'result').text)

Коротко опишу то, что тут произошло:

1. Импортировали модуль expected_conditions из библиотеки webdriver и назвали его ЕС, чтобы не писать
каждый раз его длинное название;
2. Импортировали сам класс для работы с ожиданиями WebDriverWait;
3. Использовали функцию element_to_be_clickable, которая ожидает пока элемент станет кликабельным;
4. Как только элемент стал кликабельным, управление программой передается далее, и
метод browser.find_element(By.ID, 'btn').click() и совершается клик по элементу.

Теперь чуть подробнее:

element = WebDriverWait(browser, 10).until(EC.element_to_be_clickable((By.ID, "btn")))
1. element = WebDriverWait(browser, 10) - создали экземпляр класса WebDriveWait, передав в него объект
вебдрайвера browser, где число 10 - это время, в течение которого мы ждем, пока элемент станет кликабельным,
проверка элемента происходит каждые 0,5 секунды, параметр poll_frequency=0.5 может как  уменьшить время
опроса, так и увеличить;
2. .until(EC.element_to_be_clickable(By.ID, "btn")) - к созданному экземпляру класса element применили
функцию until, которая непосредственно и выполняет всю работу. К этой функции мы применили метод 
.element_to_be_clickable, который проверяет на кликабельность переданный ему элемент, и потом функция
.click() совершает клик в нужный момент.
