8.5 Awaitable Objects

Awaitable-объекты - это объекты, которые ожидают результатов выполнения в других Awaitable-объектах, и
которые могут передавать управление другим Awaitable-объектам, пока бездействуют сами. И так по цепочке,
пока не будет выполнено все необходимое.

Например, вы написали код, который должен выполнить 100 запросов и получить содержимое ответа. В коде
ниже Awaitable-объектом будет служить сам запрос, из которого вы хотите получить текст, await
response.text(), все подобные запросы должны запускаться с оператором await, как в коде ниже:

async with aiohttp.ClientSession() as session:
  async with session.get(url) as response:
    soup = BeautifulSoup(await response.text(), 'lxml')

Когда Awaitable объект отправляет запрос, он сообщает в цикл событий, что он готов продолжить 
свою работу после получения ответа сервера. Цикл событий в это время имеет информацию обо всех
Awaitable-объектах, которые были запущены. Он выполнит все, или упадет с ошибкой, если не обработать
исключения (как это делать, мы будем говорить в следующих разделах курса).

3 типа Awaitable объектов

Сопрограммы

Сопрограмма, coroutine - асинхронная функция, которая создана с использованием ключевого слова 
async. Результатом выполнения любой сопрограммы является Awaitable-объект coroutine, который может
быть передан в цикл событий. По этой причине любая сопрограмма также считается Awaitable объектом.
Сопрограмма может быть вызвана в теле другой сопрограммы, для этого используется ключевое слово 
await перед вызовом вложенной сопрограммы.

import asyncio

async def nested():
  return print('Сопрограмма вызвана внутри сопрограммы async main()')

async def main():
  await nested()

asyncio.run(main())

#Результат
  Сопрограмма вызвана внутри сопрограммы async main()

Когда соопрограмма передает управление другой сопрограмме, она приостанавливается, сохраняя все 
свойства. Когда управление будет возвращено, она продолжит работать с того места, на котором 
остановилась. Таким образом возникает ощущение, что они работают одновременно.

Для чего использовать сопрограммы при написании парсеров? Мотором любого асинхронного кода
является цикл событий, а сопрограмма - это его топливо. Именно в них происходит работа над обработкой
и сохраняем собранной вами информации.

Любой парсер можно разделить на сопрограммы для выполнения некоторых действий параллельно, например
одновременный сбор данных и запись их в файл.

Основное преимущество сопрограмм - это их эффективность и простота написания. Сопрограмма работает
в цикле событий, который самостоятельно управляет ресурсами вашего компьютера. Вы указываете место,
где нужно переключать сопрограммы, при помощи ключевого слова await, дальше цикл событий будет
переключаться между сопрограммами и переключать их работу самостоятельно, вам не нужно думать об 
этом.

Недостатки сопрограмм.

Первое и, наверное, основное - то, что многим новичкам очень сложно разобраться в основах асинхронного
программирования. По этой причине асинхронность изучают либо специалисты, которые разбираются в
python на должном уровне, либо для работы с узкой специальностью, например, для асинхронного парсинга.

Сопрограммы - высокоуровневое решение, ускорить сложные вычисления с ее помощью не получится, в этом
случае нужна многопоточность или многопроцессорность. Но для написания парсеров нам это и не нужно.

Task - задачи

Задачи asyncio.task используются для одновременного планирования запуска нескольких сопрограмм. 
В следующих разделах курса вы увидите, что мы создаем отдельный task для каждого запроса. Для
оборачивания задачи в task используется функция asyncio.create_task(), когда задача обернута, она 
автоматически запустится, когда подойдет ее очередь.

import asyncio

async def nested(text, number):
  return print(text, number)

async def main():
  task = asyncio.create_task(nested('Переданное число', 333))
  await task

asyncio.run(main())

#Результат
  Переданное число 333
