8.4 Event Loop

Цикл событий  / event loop

Event loop - это так называемый цикл событий, в котором и происходит вся магия асинхронного кода, его еще можно
назвать диспетчером задач. Event loop создается командой asyncio.run(), высокоуровневойц асинхронной функцией.
Event loop также является ядром любого асинхронного приложения и имеет свой список задач, помимо этого делает еще
очень много всего "под капотом". В этом модуле мы не будет погружаться очень глубоко и изучать низкоуровневый код,
чтобы точно контролировать поведение наших парсеров. Для нашей цели это излишне, нам хватит простого понимания
как это устроено и как этим пользоваться.

Что же делает event loop? Он наблюдает за всеми задачами, которые мы в него передали, и если конкретная задача
дает сигнал о том, что ей нужно внимание,event loop вызывает код, который должен обработать это событие.

Пришло время разобраться в том, как работает цикл событий, на практике. Для начала нужно понять, что происзодит 
внутри цикла событий и чем это отличается от синхронного кода.

Если у вас не запускается код ниже, то удалите следующую строку

asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())

import asyncio
import aiohttp
from codetiming import Timer

#--------------------start block 1----------------------------
urls = ["http://google.com",
"http://yahoo.com",
"http://apple.com",
"http://microsoft.com",
"https://habr.com/",
"https://www.youtube.com/",
"https://stepik.org/",
"https://docs.python.org/",
"https://stackoverflow.com/",
"https://www.reg.ru/"]
#-----------------end block 1-------------------

#-----------------start block 2-----------------
async def main(url):
  with Timer(text=f"Затрачено вреени на запрос {{:.3f}} сек"):
    async with aiohttp.ClientSession() as session:
      async with session.get(url) as resp:
        print(resp.url)
#---------------------end block 2-----------------

#---------------start block 3--------------
if __name__ == '__main__':
  task = [main(link) for link in urls]
  asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
  asyncio.run(asyncio.wait(task))
#-------------------end block 3---------------

Как было обещано, будем разбирать код который вы уже видели, на этот раз у вас есть схема выполнения 
кода.

1. В первом блоке кода, мы подготовили список с сайтами которые мы хотим обработать. Это могут быть 
страницы одного сайта, заранее собранных вашей синхронной или асинхронной функцией.
2. Во втором блоке кода мы создаём корутину/сопрограмму main(), то что функция является корутиной нам 
говорит ключевое слово async. Результат выполнения функции корутины будет объект с классом corutines
3. asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy()) - самое непонятное 
происходит в этой строке, возникает справедливый вопрос, что же тут написано. Asyncio может предоставить
два цикла событий, о которых мы поговорим чуть ниже.
- set_event_loop_policy() - устанавливает политику указывающий вашей ОС каким циклом событий обрабатывать
ваши корутины, существует два типа политик, для windows и для *nix систем. Для написания парсеров нам
потребуется запомнить какой применять на вашей системе.
- WindowsSelectorEventLoopPolicy - использует наиболее эффективный селектор, который доступен в вашей ОС.
В 99% случаях вы будете использовать именно его.
- WindowsProactorEventLoopPolicy - использует порты завершения ввода/вывода IOCP. Скорее всего пригодится
при углублённом изучении асинхронного программирования.

Выше перечисленные селекторы event loop помогают решить ошибку при вызове цикла событий
RuntimeError('Event loop is closed')
